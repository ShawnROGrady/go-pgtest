// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: tasks.sql

package dbqueries

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTask = `-- name: CreateTask :one
INSERT INTO tasks (
	priority,
	name,
	description,
	assignee_id
)
VALUES (
	$1,
	$2,
	$3,
	$4
)
RETURNING id, created_at, updated_at, name, description, priority, status, assignee_id
`

type CreateTaskParams struct {
	Priority    TaskPriority
	Name        string
	Description pgtype.Text
	AssigneeID  int32
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (Task, error) {
	row := q.db.QueryRow(ctx, createTask,
		arg.Priority,
		arg.Name,
		arg.Description,
		arg.AssigneeID,
	)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		&i.Priority,
		&i.Status,
		&i.AssigneeID,
	)
	return i, err
}

const getTask = `-- name: GetTask :one
SELECT id, created_at, updated_at, name, description, priority, status, assignee_id FROM tasks WHERE id=$1
`

func (q *Queries) GetTask(ctx context.Context, id int32) (Task, error) {
	row := q.db.QueryRow(ctx, getTask, id)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		&i.Priority,
		&i.Status,
		&i.AssigneeID,
	)
	return i, err
}

const getTaskHistory = `-- name: GetTaskHistory :many
SELECT id, recorded_at, task_id, before, after FROM task_changes WHERE task_id = $1
`

func (q *Queries) GetTaskHistory(ctx context.Context, taskID int32) ([]TaskChange, error) {
	rows, err := q.db.Query(ctx, getTaskHistory, taskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TaskChange
	for rows.Next() {
		var i TaskChange
		if err := rows.Scan(
			&i.ID,
			&i.RecordedAt,
			&i.TaskID,
			&i.Before,
			&i.After,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskWithHistory = `-- name: GetTaskWithHistory :one
SELECT
	task.id, task.created_at, task.updated_at, task.name, task.description, task.priority, task.status, task.assignee_id,
	array_agg(history.recorded_at)::TIMESTAMPTZ[] AS history_recorded_ats,
	array_agg(history.before)::JSON[] AS history_befores,
	array_agg(history.after)::JSON[] AS history_after
FROM
	tasks task
	LEFT JOIN task_changes history ON (
		history.task_id = task.id
	)
WHERE
	task.id=$1
ORDER BY
	history.id ASC
`

type GetTaskWithHistoryRow struct {
	ID                 int32
	CreatedAt          time.Time
	UpdatedAt          time.Time
	Name               string
	Description        pgtype.Text
	Priority           TaskPriority
	Status             TaskStatus
	AssigneeID         int32
	HistoryRecordedAts []time.Time
	HistoryBefores     [][]byte
	HistoryAfter       [][]byte
}

func (q *Queries) GetTaskWithHistory(ctx context.Context, id int32) (GetTaskWithHistoryRow, error) {
	row := q.db.QueryRow(ctx, getTaskWithHistory, id)
	var i GetTaskWithHistoryRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		&i.Priority,
		&i.Status,
		&i.AssigneeID,
		&i.HistoryRecordedAts,
		&i.HistoryBefores,
		&i.HistoryAfter,
	)
	return i, err
}

const listClosedTasksByAssignee = `-- name: ListClosedTasksByAssignee :many
SELECT
	tasks.id, tasks.created_at, tasks.updated_at, tasks.name, tasks.description, tasks.priority, tasks.status, tasks.assignee_id
FROM
	tasks
WHERE
	assignee_id = $1
	AND status IN ('done', 'obsolete')
`

func (q *Queries) ListClosedTasksByAssignee(ctx context.Context, assigneeID int32) ([]Task, error) {
	rows, err := q.db.Query(ctx, listClosedTasksByAssignee, assigneeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Description,
			&i.Priority,
			&i.Status,
			&i.AssigneeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOpenTasksByAssignee = `-- name: ListOpenTasksByAssignee :many
SELECT
	tasks.id, tasks.created_at, tasks.updated_at, tasks.name, tasks.description, tasks.priority, tasks.status, tasks.assignee_id
FROM
	tasks
WHERE
	assignee_id = $1
	AND status NOT IN ('done', 'obsolete')
`

func (q *Queries) ListOpenTasksByAssignee(ctx context.Context, assigneeID int32) ([]Task, error) {
	rows, err := q.db.Query(ctx, listOpenTasksByAssignee, assigneeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Description,
			&i.Priority,
			&i.Status,
			&i.AssigneeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasks = `-- name: ListTasks :many
SELECT
	tasks.id, tasks.created_at, tasks.updated_at, tasks.name, tasks.description, tasks.priority, tasks.status, tasks.assignee_id
FROM
	tasks
WHERE
	status = coalesce($3, status)
	AND assignee_id = coalesce($4, assignee_id)
LIMIT $1
OFFSET $2
`

type ListTasksParams struct {
	Limit      int32
	Offset     int32
	Status     NullTaskStatus
	AssigneeID pgtype.Int4
}

func (q *Queries) ListTasks(ctx context.Context, arg ListTasksParams) ([]Task, error) {
	rows, err := q.db.Query(ctx, listTasks,
		arg.Limit,
		arg.Offset,
		arg.Status,
		arg.AssigneeID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Description,
			&i.Priority,
			&i.Status,
			&i.AssigneeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTask = `-- name: UpdateTask :one
UPDATE
	tasks
SET
	updated_at = now(),
	name = coalesce($2, name),
	description = (CASE WHEN $3::bool
				THEN $4
				ELSE description
			END),
	priority = coalesce($5, priority),
	status = coalesce($6, status),
	assignee_id = coalesce($7, assignee_id)
WHERE
	id = $1
RETURNING id, created_at, updated_at, name, description, priority, status, assignee_id
`

type UpdateTaskParams struct {
	ID             int32
	Name           pgtype.Text
	SetDescription bool
	Description    pgtype.Text
	Priority       NullTaskPriority
	Status         NullTaskStatus
	AssigneeID     pgtype.Int4
}

func (q *Queries) UpdateTask(ctx context.Context, arg UpdateTaskParams) (Task, error) {
	row := q.db.QueryRow(ctx, updateTask,
		arg.ID,
		arg.Name,
		arg.SetDescription,
		arg.Description,
		arg.Priority,
		arg.Status,
		arg.AssigneeID,
	)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		&i.Priority,
		&i.Status,
		&i.AssigneeID,
	)
	return i, err
}
